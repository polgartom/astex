insert_text_at_raw :: (buffer: *Buffer, at: s64, text: string) {
    if !text.count return;
    
    maybe_grow(buffer, text.count);

    insert_at      := buffer.data  + at;
    new_right      := insert_at    + text.count;
    right_rem_size := buffer.count - (insert_at - buffer.data);
    right_rem_size  = max(0, right_rem_size);

    if right_rem_size then c_memmove(new_right, insert_at, cast(u64)right_rem_size);
    memmove(insert_at, text.data, text.count);

    buffer.count += text.count;
}

insert_text_at :: (editor: *Editor, buffer: *Buffer, at: s64, text: string, $history := true) {
    #if history {
        add_history(editor, buffer, .INSERT, text, Range.{at, at + text.count});
    }

    {
        maybe_grow(buffer, text.count);

        insert_at      := buffer.data  + at;
        new_right      := insert_at    + text.count;
        right_rem_size := buffer.count - (insert_at - buffer.data);
        right_rem_size  = max(0, right_rem_size);

        if right_rem_size then c_memmove(new_right, insert_at, cast(u64)right_rem_size);
        memmove(insert_at, text.data, text.count);

        buffer.count += text.count;
    }

    buffer.dirty = true;
    buffer.modtime = ms_since_init();

    // @Temporary
    // We must rescan the lines right after text insertion because the byte_pos_to_row_col_index() works on the buffer's "row_table" that is dirty at that point so
    // if we append some text to the current line after the last character the byte_pos_to_row_col_index() will think that we on the next row.
    // This commit buffer procedure will no cause any overhead by calling it multiple times because we rescan the lines only if it's dirty.
    commit_buffer_changes(buffer);

    for *c: buffer.cursor_backup {
        steps := text.count;
        
        if c.pos > 0 && c.pos >= at {
            c.pos += steps;
        }
        if c.sel > 0 && c.sel >= at {
            c.sel += steps;
        }
        clamp_cursor(c, buffer.count);
    }

    for *e : editors {
        if e == editor continue;
        
        if e.active_buffer == buffer {
            steps := text.count;
            c := *e.cursor;
            if c.pos > 0 && c.pos >= at {
                c.pos += steps;
            }
            if c.sel > 0 && c.sel >= at {
                c.sel += steps;
            }
            clamp_cursor(c, buffer.count);
        }
    }
}

// Shift the entire *used* buffer memory to the left, typically for "deleting" characters from the right
shift_left :: (editor: *Editor, using buffer: *Buffer, to: s64, from: s64) { // @Cleanup Naming?!
    if to == from return;
    assert(to < from);

    dest   := data  + to;
    source := data  + from;
    size   := count - from;

    c_memmove(dest, source, xx size);
    count -= (from - to);

    dirty = true;
    modtime = ms_since_init();

    // @Todo: Better explanation
    // We don't need to commit the buffer changes
    // the byte_pos_to_row_col_index() will work because we apply deletion not insertion therefore that procedure won't mess up anything

    // @Incomplete: Can be better
    for *e : editors {
        if e != editor && e.active_buffer == buffer {
            c0, c1 := get_cursor_min_max_indecies_as_pointers(*e.cursor);

            steps := from - to;

            if is_overlap(.{c0.*, c1.*}, .{to, from}) {
                if c1.* <= from {
                    c1.* = to;
                } else {
                    c1.* -= steps;
                }

                if c0.* >= to {
                    c0.* = to;
                }

            } else {
                if c0.* > to {
                    c0.* -= steps;
                }
                if c1.* > from {
                    c1.* -= steps;
                }
            }

            clamp_cursor(*e.cursor, buffer.count);
        }
    }
}

insert_os_clipboard_text_at_cursor :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor) {
    if buffer.readonly return;

    t := Clipboard.os_clipboard_get_text();
    defer free(t);

    // @Speed
    normalize_line_endings(*t);
    // spaces := talloc_string(tab_size);
    // for spaces { spaces[it_index] = " "; } 
    // text := t;
    //text := replace(t, "\t", spaces);
    //defer free(text);

    // @Todo: Validate if the input data is valid utf8!

    insert_text_at_cursor(editor, buffer, cursor, t);
}

replace_text_at :: (editor: *Editor, buffer: *Buffer, range: Range, new_text: string, $history := true) {
    if buffer.readonly return;

    #if history {
        add_history(editor, buffer, .REPLACE, new_text, range);
    }

    remove_text_from_left(editor, buffer, range.start, range.end - range.start, history=false);
    insert_text_at(editor, buffer, range.start, new_text, history=false);
}

replace_selection :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor, text: string, $history := true) {
    if buffer.readonly return;

    start, end := selected_range(cursor);
    replace_text_at(editor, buffer, Range.{start, end}, text, history);
    
    set_cursor_pos(buffer, cursor, start + text.count, horizontal=true);
}

insert_text_at_cursor :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor, text: string, $history := true) {
    if buffer.readonly return;

    if has_selection(cursor) {
        replace_selection(editor, buffer, cursor, text, history);
        return;
    }
    
    insert_text_at(editor, buffer, cursor.pos, text, history);

    set_cursor_pos(buffer, cursor, cursor.pos + text.count, horizontal=true);
}

remove_text_from_right_at_cursor :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor, bytes_to_del: s64, $history := true) {
    if buffer.readonly return;

    remove_text_from_right(editor, buffer, cursor.pos, bytes_to_del, history);
    
    set_cursor_pos(buffer, cursor, cursor.pos - bytes_to_del, horizontal=true);
}

remove_text_from_right :: (editor: *Editor, buffer: *Buffer, at: s64, bytes_to_del: s64, $history := true) {
    if buffer.readonly return;

    remove_text_from_left(editor, buffer, at - bytes_to_del, bytes_to_del, history);
}

remove_text_from_left_at_cursor :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor, bytes_to_del: s64, $history := true) {
    if buffer.readonly return;

    remove_text_from_left(editor, buffer, cursor.pos, bytes_to_del, history);
}

remove_text_from_left :: (editor: *Editor, buffer: *Buffer, at: s64, bytes_to_del: s64, $history := true) {
    if buffer.readonly return;

    pos1 := clamp(at, 0, buffer.count-1);
    pos2 := clamp(at + bytes_to_del, 0, buffer.count);
    if pos1 == pos2 return; // @Cleanup: We do the same check in the shift_left() procedure.
    
    #if history {
        deleted_text := slice(buffer, pos1, pos2 - pos1);
        add_history(editor, buffer, .DELETE, deleted_text, Range.{pos1, pos2});
    }

    shift_left(editor, buffer, pos1, pos2);
}

delete_selected_range_if_has_any :: inline (editor: *Editor, buffer: *Buffer, cursor: *Cursor) -> (text_deleted: bool) {
    if buffer.readonly return false;

    if has_selection(editor.cursor) {
        delete_selected_range(editor, buffer, *editor.cursor);
        return true;
    }
    return false;
}

delete_selected_range :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor, $history := true) {
    if buffer.readonly return;
    if !has_selection(cursor) return;

    start, end := selected_range(cursor);
    remove_text_from_left(editor, buffer, start, end - start, history=history);
    set_cursor_pos(buffer, cursor, start, horizontal=true, with_selection=true);
}

copy_selection_to_os_clipboard :: (buffer: *Buffer, cursor: *Cursor) {
    text := get_selection_as_string(buffer, cursor);
    Clipboard.os_clipboard_set_text(text);
}

cut_selection_and_copy_to_os_clipboard :: (editor: *Editor, buffer: *Buffer, cursor: *Cursor) {
    if buffer.readonly return;
    if !has_selection(cursor) return;

    text := get_selection_as_string(buffer, cursor);
    Clipboard.os_clipboard_set_text(text);

    delete_selected_range(editor, buffer, cursor);
}

is_valid_line :: inline (buffer: *Buffer, line: s64) -> bool {
    if line < 0 || line - 1 >= buffer.row_table.count return false;
    return true;
}

get_current_line :: inline (using buffer: *Buffer, byte_pos: s64) -> s64 {
    return find_row_index(buffer, byte_pos) + 1;
}

get_row_as_string :: inline (using buffer: *Buffer, index: s64) -> string {
    assert(index < row_table.count);

    s := get_row_as_string(buffer, row_table[index]);
    return s;
}

get_row_as_string :: inline (using buffer: *Buffer, row: Row_Info) -> string {
    s := slice(buffer, row.start, row.size);
    return s;
}

get_selection_as_string :: (buffer: *Buffer, cursor: *Cursor) -> string {
    start, end := selected_range(cursor);
    return slice(buffer, start, end - start);
}

next_character_pos :: (buffer: *Buffer, at: s64) -> (pos: s64, moved: bool) {
    assert(at > -1 || at <= buffer.count);

    if at == buffer.count return at, false;

    byte := buffer.data[at];
    pos := at + 1 + trailingBytesForUTF8[byte];
    return pos, pos != at;
}

prev_character_pos :: (buffer: *Buffer, at: s64) -> (pos: s64, moved: bool) {
    pos := prev_char_byte_offset(buffer, at);
    return pos, pos != at;
}

count_buffers :: (using editor: *Editor, initialized: bool) -> (count: s64) {
    count := 0;
    for buffers {
        if it.initialized == initialized then count += 1;
    }

    return count;
}

find_buffer_by_filepath :: (filepath: string) -> *Buffer {
    for buffers {
        if it.exists_on_disk {
            if it.filepath == filepath return it;
        }
    }

    return null;
}

create_or_find_empty_buffer :: (editor: *Editor) -> *Buffer { // @Cleanup @Todo: Rename it!
    buffer: *Buffer;

    buffer = create_buffer();
    
    initialize_buffer(buffer);

    return buffer;
}

create_buffer :: () -> *Buffer {
    id: u64;
    retry := true;
    while retry {
        id = random_get();
        retry = false;
        for b: buffers if b.id == id { retry = true; ll("id collision: % %\n", id, b.id); break; }
    }
    
    buffer := New(Buffer);
    buffer.id = id;
    array_add(*buffers, buffer);

    return buffer;
}

create_stdout_buffer :: () -> *Buffer {
    using buffer := New(Buffer);
    
    kind = .stdout;
    readonly = true;
    pinned = true;
    
    initialize_buffer(buffer);
    
    return buffer;
}

initialize_buffer :: (buffer: *Buffer) {
    if buffer.initialized return;
    
    maybe_grow(buffer, BUFFER_PAGE_SIZE);
    
    buffer.initialized = true;

    rescan_line_ends(buffer);
    for *c: buffer.cursor_backup    reset_cursor(c);
    
    buffer.hash = hash_from_buffer(buffer);
    buffer.disk_hash = buffer.hash;
}

commit_buffer_changes :: (buffer: *Buffer, force := false) {
    if !force {
        if !buffer.dirty return;
    }

    buffer.dirty = false;
    buffer.was_dirty_on_frame = true;
    buffer.tokenization_requested = true;

    rescan_line_ends(buffer);

    for *e: editors {
        if e.active_buffer == buffer {
            clamp_cursor(*e.cursor, buffer.count);
        }
    }
}

rescan_line_ends :: (using buffer: *Buffer) {
    timer := seconds_since_init();

    array_reset_keeping_memory(*row_table);

    s := to_string(buffer);
    
    pos := 0;
    while true {
        ln_index := inline find_index_from_left(s, #char "\n");
        if ln_index == -1 {
            inline array_add(*row_table, .{start=pos, end=pos+s.count, size=s.count});
            break;
        }

        size := ln_index;
        pos += size;
        inline array_add(*row_table, .{start=pos-size, end=pos, size=size});

        ln_index += 1;
        inline advance(*s, ln_index);

        pos += 1; // because of the line end
    }

    row_table_recalc_time = (seconds_since_init() - timer) * 1000;
}

get_character_as_string_at :: (buffer: *Buffer, at: s64, include_line_end_character := false) -> string {
    // @Todo VALIDATIONS!
    if at >= buffer.count return "";
    if !include_line_end_character && buffer.data[at] == #char "\n" return ""; // @Hacky

    s := slice(buffer, at, buffer.count - at);
    bytes := 1 + trailingBytesForUTF8[s[0]];
    s.count = bytes;
    return s;
}

slice :: inline (buffer: *Buffer, start: s64, count: s64) -> string {
    s := to_string(buffer);
    return slice(s, start, count);
}

slice :: inline (buffer: *Buffer, start_ptr: *u8, end_ptr: *u8) -> string {
    end := buffer.data + buffer.count - 1;
    if start_ptr >= buffer.data + buffer.count then start_ptr = end;
    if end_ptr >= buffer.data + buffer.count   then end_ptr   = end;

    s: string;
    s.data  = start_ptr;
    s.count = end_ptr - start_ptr;

    return s;
}

to_string :: inline (buffer: *Buffer) -> string {
    s: string = ---;
    s.count = buffer.count;
    s.data  = buffer.data;
    return s;
}

hash_from_buffer :: inline (using buffer: *Buffer) -> u64 {
    return meow_hash(.{data = data, count = count});
}

maybe_grow :: (buffer: *Buffer, size: s64) {
    assert(size > -1);

    if size == 0 then size = BUFFER_PAGE_SIZE;
    desired_size := buffer.count + size;

    if desired_size >= buffer.allocated {
        new_size := buffer.allocated + desired_size;
        new_size  = Align(new_size, BUFFER_PAGE_SIZE);
        new_data := cast(*u8)c_malloc(xx new_size);
        assert(new_data != null);
        zero_memory(new_data, new_size);

        if buffer.data {
            memmove(new_data, buffer.data, buffer.allocated);
            c_free(buffer.data);
        }

        buffer.data      = new_data;
        buffer.allocated = new_size;

        {
            // Allocates colors
            new_colors_data := cast(*Color)c_malloc(xx new_size);
            assert(new_colors_data != null);
            memset(new_colors_data, cast(u8)Color.TEXT_DEFAULT, buffer.allocated);

            if buffer.colors.count {
                memmove(new_colors_data, buffer.colors.data, buffer.colors.count);
                c_free(buffer.colors.data);
            }

            buffer.colors.data  = new_colors_data;
            buffer.colors.count = new_size;
        }

    }
}

buffer_reset :: (using buffer: *Buffer) {
    for *e: editors {
        found := find_buffer_within_editor_tabs(e, buffer);
        assert(found == false, "The buffer must be removed from all of the editors tabs! This editor is uses it: % ; buffer: %\n", e.*, buffer.*);
    }

    ll("[%] (%)", buffer, ifx buffer.filepath then buffer.filepath else buffer.name);
    
    for h: history {
        free_string(*h.text);
        free_string(*h.old_text);
        #if DEBUG {
            free_string(*h.snapshot);
        }
    }
    
    #insert __BUFFER_DESTROY_CODE;
    
    new_buffer: Buffer;
    buffer.* = new_buffer;
    
    initialize_buffer(buffer);
}

buffer_destroy :: (using buffer: *Buffer) {
    for *e: editors {
        found := find_buffer_within_editor_tabs(e, buffer);
        assert(found == false, "The buffer must be removed from all of the editors tabs! This editor is uses it: % ; buffer: %\n", e.*, buffer.*);
    }
    
    ll("Buffer freed completely. [%] (%)", buffer, ifx buffer.filepath then buffer.filepath else buffer.name);

    for h: history {
        free_string(*h.text);
        free_string(*h.old_text);
        #if DEBUG {
            free_string(*h.snapshot);
        }
    }
    
    #insert __BUFFER_DESTROY_CODE;
    
    free(buffer);
}

batch_up_undos :: (history: [] Buffer_History, history_index: s64) -> [] Buffer_History {
    assert(history_index >= 0);
    assert(history_index < history.count);

    h := history[history_index];
    batch: [] Buffer_History;
    batch.data = history.data + history_index;
    batch.count = 1;
    
    list := array_view(history, 0, history_index);
    start_index := history_index;
    
    if h.edit_group_id != 0 {
        for < list {
            if it.edit_group_id != h.edit_group_id break;
            start_index = it_index;
        }
        
        batch = array_view(history, start_index, (history_index+1) - start_index);
    
    } else {
        if h.type == .INSERT {
            expect_alphanum := is_alphanum(h.text[0]);
            
            for < list {
                if it.type != h.type break;
                if expect_alphanum ^ is_alphanum(it.text[0]) break;
                start_index = it_index;
            }
    
            batch = array_view(history, start_index, (history_index+1) - start_index);
            
        } else if h.type == .DELETE {
            nochars := utf8_character_count(h.text);
            if nochars != 1 return batch; // Because multi-chars deletion already kinda batched up, we only interested about single character histories for now.
            
            expect_alphanum := is_alphanum(h.text[0]);
            
            for < list {
                if it.type != h.type break;
                nochars = utf8_character_count(it.text);
                if nochars != 1 break;
                if expect_alphanum ^ is_alphanum(it.text[0]) break;
                start_index = it_index;
            }
    
            batch = array_view(history, start_index, (history_index+1) - start_index);
            
        } else if h.type == .REPLACE {
            // Skip it..
        }
    }
    

    return batch;
}

batch_up_redos :: (history: [] Buffer_History, history_index: s64) -> [] Buffer_History {
    assert(history_index >= 0);
    assert(history_index < history.count);

    h := history[history_index];
    batch: [] Buffer_History;
    batch.data = history.data + history_index;
    batch.count = 1;
    
    list := advance(history, history_index);
    end_index := history_index;

    if h.edit_group_id != 0 {
        for list {
            if it.edit_group_id != h.edit_group_id break;
            end_index += 1;    
        }
        
        batch = array_view(history, history_index, end_index-history_index);
        
    } else {
        if h.type == .INSERT {
            expect_alphanum := is_alphanum(h.text[0]);
                    
            for list {
                if it.type != h.type break;
                if expect_alphanum != is_alphanum(it.text[0]) break;
                end_index += 1;
            }
            
            batch = array_view(history, history_index, end_index-history_index);
            
        } else if h.type == .DELETE {
            nochars := utf8_character_count(h.text);
            if nochars != 1 return batch; // Because multi-chars deletion already kinda batched up, we only interested about single character histories for now.
        
            expect_alphanum := is_alphanum(h.text[0]);
            end_index       := history_index;
            
            for list {
                if it.type != h.type break;
                nochars = utf8_character_count(it.text);
                if nochars != 1 break;
                if expect_alphanum != is_alphanum(it.text[0]) break;
                end_index += 1;
            }
            
            batch = array_view(history, history_index, end_index-history_index);
            
        } else if h.type == .REPLACE {
            // Skip it..
        }
    
    }


    return batch;
}

undo :: (editor: *Editor, using buffer: *Buffer) {
    if !history.count || history_index == -1 return;

    undos := batch_up_undos(history, history_index);
    for < h: undos { // We perform undos so we have to go backward        
        if #complete h.type == {        
            case .INSERT;
                to   := h.range.start;
                from := h.range.end;
                if to >= from || to < 0 || to > buffer.count-1 || from < 0 || from > buffer.count {
                    log_error("Unable to revert (undo) the % due to the invalid start and end point of the text. %", h.type, h);
                    reset_history(buffer);
                    return;
                }

                shift_left(editor, buffer, to, from);
                editor.cursor = h.cursor;
                set_cursor_pos(buffer, *editor.cursor, to, horizontal=true); 
                history_index -= 1;

            case .DELETE;
                to := h.range.start;
                if to < 0 || to > buffer.count {
                    log_error("Unable to revert (undo) the % due to the invalid insertion point. %", h.type, h);
                    reset_history(buffer);
                    return;
                }
                
                insert_text_at(editor, buffer, to, h.text, history=false);
                editor.cursor = h.cursor;
                set_cursor_pos(buffer, *editor.cursor, to + h.text.count, horizontal=true);
                history_index -= 1;

            case .REPLACE;
                assert(h.text.count > 0, "\n%\n", h);
                start := h.range.start;
                end   := h.range.start + h.text.count;
                if start >= end || start < 0 || start > buffer.count || end < 0 || end > buffer.count {
                    log_error("Unable to revert (undo) the % due to the invalid range given for the replacement. %", h.type, h);
                    reset_history(buffer);
                    return;
                }

                replace_text_at(editor, buffer, Range.{start, end}, h.old_text, history=false);
                editor.cursor = h.cursor;
                clamp_cursor(*editor.cursor, buffer.count);
                editor.cursor.col = byte_pos_to_row_col_index(buffer, editor.cursor.pos);
                history_index -= 1;

                // We don't want to change these type of undos

            case .UNDEFINED;
                assert(false, "Undefined history type: %\n", h);
        }        
    }

    #if DEBUG {
        if undos.count {
            h := undos[0];
            s := to_string(buffer);
            current_hash := hash_from_buffer(buffer);
            if h.hash != current_hash {
                log("\n\n-----------\nInvalid hash (undo/after): %  % | \n%\n", h.hash, current_hash, h);
                File.write_entire_file(tprint("./dumps/diff/%", current_hash), s);
                File.write_entire_file(tprint("./dumps/diff/%", h.hash), h.snapshot);
            }
        }
    }
}

redo :: (editor: *Editor, using buffer: *Buffer) {
    if !history.count || history_index == history.count-1 return;

    redos := batch_up_redos(history, history_index+1);

    for h: redos {
        if h.type == {
            case .INSERT;
                to := h.range.start;
                if to < 0 || to > buffer.count {
                    log_error("Unable to revert (redo) the % due to the invalid insertion point. %", h.type, h);
                    reset_history(buffer);
                    return;
                }

                insert_text_at(editor, buffer, to, h.text, history=false);
                editor.cursor = h.cursor;
                set_cursor_pos(buffer, *editor.cursor, to + h.text.count, horizontal=true);
                Clamp(*editor.cursor.pos, 0, buffer.count);
                history_index += 1;

            case .DELETE;
                // @BUG: We'll get invalid range!!!
                to   := h.range.start;
                from := h.range.end;
                if to >= from || to < 0 || to > buffer.count || from < 0 || from > buffer.count {
                    log_error("Unable to revert (redo) the % due to the invalid start and end point of the text. % | to: % ; from: % ; bufcount: %\n", h.type, h, to, from, buffer.count);
                    reset_history(buffer);
                    return;
                }

                shift_left(editor, buffer, to, from);
                editor.cursor = h.cursor;
                set_cursor_pos(buffer, *editor.cursor, to, horizontal=true); 
                Clamp(*editor.cursor.pos, 0, buffer.count);
                history_index += 1;

            case .REPLACE;
                // @INCOMPLETE @XXX ???
                start := h.range.start;
                end   := h.range.start + h.old_text.count;
                if start >= end || start < 0 || start > buffer.count || end < 0 || end > buffer.count {
                    log_error("Unable to revert (redo) the % due to the invalid range given for the replacement. %", h.type, h);
                    reset_history(buffer);
                    return;
                }

                replace_text_at(editor, buffer, Range.{start, end}, h.text, history=false);
                editor.cursor = h.cursor;
                to := end + h.text.count - (end - start);
                if to > buffer.count then to = buffer.count;
                //set_cursor_pos(buffer, *editor.cursor, to, horizontal=true); 
                // clamp_cursor(*editor.cursor, buffer.count);
                editor.cursor.col = byte_pos_to_row_col_index(buffer, editor.cursor.pos);
                history_index += 1;
                
                // We don't want to change these type of redos

            case .UNDEFINED;
                assert(false, "Undefined history type: %\n", h);
        }
    }
}

add_history :: (editor: *Editor, using buffer: *Buffer, new_history: Buffer_History) -> *Buffer_History {
    if history.count && history_index != history.count-1 {
        // We should truncate the history because...
        new_size := buffer.history_index+1;
        history.count = new_size;
        Clamp(*history_index, -1, history.count-1);
    }

    h := array_add2(*history);
    h.type   = new_history.type;
    h.range  = new_history.range;
    h.cursor = new_history.cursor;

    #if DEBUG {
        assert(!!new_history.snapshot);
        assert(!!new_history.hash);
        
        modify_string(*h.snapshot, new_history.snapshot);
        h.hash = new_history.hash;
    }

    assert(!!new_history.text);
    modify_string(*h.text, new_history.text);
    
    if new_history.type == .REPLACE {
        assert(!!new_history.old_text);
        modify_string(*h.old_text, new_history.old_text);
    }
    
    history_index += 1; // also we jump -1 to 0 if no history exists
    
    return h;
}

add_history :: (editor: *Editor, using buffer: *Buffer, $type: Buffer_History.Type, text: string, range: Range, _old_text: string = "" /*for replace*/) -> *Buffer_History {
    if history.count && history_index != history.count-1 {
        // We should truncate the history because...
        new_size := buffer.history_index+1;
        history.count = new_size;
        Clamp(*history_index, -1, history.count-1);
    }

    h := array_add2(*history);
    h.type   = type;
    h.range  = range;
    h.cursor = editor.cursor;
    h.edit_group_id = history_current_edit_group_id;
    
    #if DEBUG {
        modify_string(*h.snapshot, to_string(buffer));
        h.hash = meow_hash(cast([]u8)h.snapshot);
    }

    modify_string(*h.text, text);

    #if type == .REPLACE {
        old_text := slice(buffer, range.start, range.end - range.start);
        modify_string(*h.old_text, old_text);
    }
    
    history_index += 1; // also we jump -1 to 0 if no history exists
    
    return h;
}

last_history :: (using buffer: *Buffer) -> *Buffer_History {
    if buffer.history_index > -1 && buffer.history_index < buffer.history.count {
        return *buffer.history[buffer.history_index];
    }

    return null;
}

reset_history :: (using buffer: *Buffer) {
    history_index = -1;
    array_reset_keeping_memory(*history);
}

push_history_edit_group :: (b: *Buffer, id: u64) {
    array_add(*b.history_edit_group_id_stack, b.history_current_edit_group_id);
    
    b.history_current_edit_group_id = id;
}

pop_history_edit_group :: (b: *Buffer) {
    id := pop(*b.history_edit_group_id_stack);
    b.history_current_edit_group_id = id;
}

switch_editor_mode :: (switch_to: Program_Mode) { // @Cleanup: Remove it!
    if switch_to == .EDITOR {
        e, b := get_active_editor_and_buffer();
        if !e {
            log_error("Unable to switch the .EDITOR mode if we have no active editor!\n");
            return;
        }
    }
    
    mode = switch_to;
}

open_file_or_create_empty_buffer :: (editor: *Editor, _filepath: string) -> *Buffer {
    filepath := File.get_absolute_path(_filepath);
    path_overwrite_separators(filepath, #char "/");

    for buffers {
        if it.filepath == filepath return it;
    }

    buffer: *Buffer;
    for buffers {
        if it.initialized && !it.readonly && !it.exists_on_disk && !it.dirty && !it.count {
            buffer = it;
            break;
        }
    }

    if !buffer {
        buffer = create_or_find_empty_buffer(editor);
    }

    modify_string(*buffer.filepath, filepath);
    buffer.exists_on_disk = file_exists(filepath);
    
    if buffer.exists_on_disk {
        input := File.read_entire_file(filepath);
        if input {
            _input := input;
            defer free(_input);

            normalize_line_endings(*_input); // Converts any \r\n into \n, overwriting the original data.
            //spaces := talloc_string(tab_size);
            //for spaces { spaces[it_index] = " "; } 
            //final_text := replace(_input, "\t", spaces);
            //defer free(final_text);
            final_text := _input;
            insert_text_at(editor, buffer, 0, final_text, history=false);
            buffer.last_writetime = file_modtime_and_size(filepath);
        }
        
        if platform_path_equals(get_project_config_path(), filepath) || platform_path_equals(get_editor_config_path(), filepath) {
            buffer.kind = .editor_config;
        }

        commit_buffer_changes(buffer, force=true);
    }

    ext := path_extension(buffer.filepath);
    buffer.language  = language_from_file_extension(ext);
    buffer.hash      = hash_from_buffer(buffer);
    buffer.disk_hash = buffer.hash;
    buffer.disk_state = ifx buffer.exists_on_disk then .exists else .not_exists;

    return buffer;
}

buffer_reload_from_disk :: (editor: *Editor, using buffer: *Buffer) -> bool {
    should_reload_from_disk = false;
    
    if !exists_on_disk return false;

    input, ok := File.read_entire_file(filepath);
    if !ok return false;
    defer free(input);

    if input {
        normalize_line_endings(*input); // Converts any \r\n into \n, overwriting the original data.
        replace_text_at(editor, buffer, .{start=0, end=buffer.count}, input, history=true);
        last_writetime = file_modtime_and_size(filepath);
    }
    
    disk_hash = hash_from_buffer(buffer);
    disk_state = .exists;
    
    commit_buffer_changes(buffer, force=true);
    return true;
}

buffer_write_to_disk :: (using buffer: *Buffer) -> bool {
    assert(!!filepath, "No filepath given! Buffer: %\n", buffer.*);
    
    exists := file_exists(filepath);
    if !exists {
        dir := path_strip_filename(filepath);
        assert(!!dir);
        File.make_directory_if_it_does_not_exist(dir);
    }

    ok := File.write_entire_file(filepath, to_string(buffer));
    if !ok {
        log_error("Unable to write the buffer data to '%'!\n", filepath);
        return false;
    }

    exists_on_disk = true;
    last_writetime = file_modtime_and_size(filepath);
    disk_hash = hash_from_buffer(buffer);
    disk_state = .exists;

    return true;
}

save_buffer :: (using buffer: *Buffer) -> bool {
    if !filepath {
        path, ok := dialog_get_save_file_name();
        if !ok return false;
        modify_string(*filepath, path);
        path_unify_sepa(filepath);
        
        ext := path_extension(path);
        language = language_from_file_extension(ext);
    }

    ok := buffer_write_to_disk(buffer);
    
    if buffer.kind == .editor_config {
        // @Temporary: We could flag the buffer, like .BUFFER_EDITOR_CONFIG or .BUFFER_PROJECT_CONFIG
        // Also we should put this in file watcher procedure
        config_path := get_editor_config_path();
        if file_exists(config_path) && platform_path_equals(config_path, filepath) {
            load_global_config();
            init_fonts();
        }
        config_path = get_project_config_path();
        if file_exists(config_path) && platform_path_equals(config_path, filepath) {
            // reset_keymaps(*keymap_set);
            load_project_config();
        }
    }

    return ok;
}

close_tab :: (editor: *Editor, buffer: *Buffer) {
    if buffer.pinned {
        ll("Pinned buffer cannot be closed! Buffer: %\n", buffer.*);
        return;
    }

    found, index := find_buffer_within_editor_tabs(editor, buffer);
    if !found return;
        
    removed := remove_buffer_from_editor_tabs(editor, buffer);
    assert(removed, "[%] %\n", buffer, buffer.*);
    
    some_editor_still_using_it := false;
    for *e: editors {
        found := find_buffer_within_editor_tabs(e, buffer);
        if found {
            ll("Some editor still using the buffer so we won't free it. [%] (%)\n", buffer, buffer.filepath);
            some_editor_still_using_it = true;
            break;
        }
    }
    
    if some_editor_still_using_it {
            
    } else {
        buffer_destroy(buffer);
        for b: buffers {
            if b == buffer {
                remove b;
                break;
            }
        }
    }
    
    if get_left_editor() == editor && editor.tabs.count == 0 {
        move_right_editor_tabs_to_left(editor, get_right_editor());
    }
    
    if get_right_editor() == editor && editor.tabs.count == 0 {
        left_editor := get_left_editor();
        if left_editor.tabs.count {
            change_active_editor(left_editor);
        }
    }
    
    ll("buffers: %\n", buffers);
    if buffers.count == 0 {
        for *e: editors {
            if e == get_bottom_editor() continue;
            assert(e.active_buffer == null, "%\n", e);
        }
    }
}

move_right_editor_tabs_to_left :: (left_editor: *Editor, right_editor: *Editor) {
    assert(left_editor == get_left_editor());
    assert(right_editor == get_right_editor());
        
    right_editor.active_buffer = null;
        
    for tab: right_editor.tabs {
        // tab.cursor_backup[1] = tab.cursor_backup[0];
        maybe_add_buffer_to_editor_tabs(left_editor, tab, append_to_end=true);
    }
    for tab: right_editor.tabs {
        remove tab;
    }
    assert(right_editor.tabs.count == 0, "%\n", right_editor.*);
    
    if left_editor.tabs.count {
        change_active_editor(left_editor);
    } else {
        mode = .SPLASH;
    }
}

is_unsaved :: inline (using buffer: *Buffer) -> bool {
    return hash != disk_hash;
}

is_active :: inline (using e: *Editor) -> bool {
    return e == active_editor;
}

is_active :: inline (using e: *Editor, using b: *Buffer) -> bool {
    return e.active_buffer == b;
}

get_left_editor  :: inline () -> *Editor { return *editors[0]; } // @Temporary!
get_right_editor :: inline () -> *Editor { return *editors[1]; } // @Temporary!
get_bottom_editor :: inline () -> *Editor { return *editors[2]; } // @Temporary!

get_not_active_editor :: () -> *Editor {
    bottom_editor := get_bottom_editor();
    for *e: editors {
        if !e.visible && e != bottom_editor {
            return active_editor; // Fallback
        }
    }
    
    if *editors[0] != active_editor return *editors[0];
    return *editors[1];
}

get_buffer_index :: (buffer: *Buffer) -> s64 {
    for buffers {
        if buffer == it {
            return it_index;
        }
    }

    assert(false);
    return -1;
}

get_editor_index :: (editor: *Editor) -> s64 {
    for * editors {
        if editor == it return it_index;
    }

    assert(false);
    return -1;
}

buffer_end :: inline (buffer: *Buffer) -> *u8 {
    return buffer.data + buffer.count;
}

get_active_editor_and_buffer :: () -> (editor: *Editor, buffer: *Buffer) {
    if !active_editor return null, null;
    return active_editor, active_editor.active_buffer;
}

force_editors_viewports_recalculations :: () {
    for *e: editors {
        e.cursor.moved = true;
        e.tabs_force_offset_check = true;
    }
}

change_active_buffer :: (editor: *Editor, next_buffer: *Buffer) {
    current_buffer := editor.active_buffer;
    // if current_buffer == next_buffer return;
    editor_index := get_editor_index(editor);
    if current_buffer {
        current_buffer.cursor_backup[editor_index] = editor.cursor; // Backing up the current cursor
    }

    maybe_add_buffer_to_editor_tabs(editor, next_buffer);
    editor.tabs_force_offset_check = true;

    editor.active_buffer = next_buffer;
    editor.cursor = next_buffer.cursor_backup[editor_index];
    clamp_cursor(*editor.cursor, next_buffer.count);

    editor.left_offset = 0.0;
    editor.top_offset  = 0.0;
    scroll_to_cursor(editor, editor.cursor, animation_duration=0);
}

change_active_editor :: (editor: *Editor, change_mode := true) { // @Cleanup
    if !editor.active_buffer && editor.tabs {
        change_active_buffer(editor, editor.tabs[0]);
    }
    
    editor.visible = true;
    active_editor = editor;
    
    if change_mode {
        switch_editor_mode(.EDITOR);
    }
}

scroll_to_cursor :: (editor: *Editor, cursor: Cursor, animation_duration: float = 0.08) {
    assert(editor.active_buffer != null);
    buffer := editor.active_buffer;
    r := editor.rect_for_draw;
    if r.w == 0 || r.h == 0 return;
    
    // Viewport (X)
    x_threshold := em(1.0, r_font) * 2;
    mx := get_cursor_x(buffer, *editor.cursor);
    mx = cast(s64)(mx - editor.left_offset - r.w);

    target := editor.left_offset;
    if mx + x_threshold > 0 {
        target += abs(mx + x_threshold);
    } else if abs(mx) > xx r.w {
        target -= abs(mx) - r.w;
        if target < 0 then target = 0;
    }

    if target != editor.left_offset {
        if animation_duration {
            anim_x: Anim;
            anim_x.active = true;
            anim_x.start  = editor.left_offset;
            anim_x.target = target;
            anim_x.duration = animation_duration;
            anim_x.started_at = frame_time64;
            editor.x_scroll_anim = anim_x;
        } else {
            editor.left_offset = target;
            editor.x_scroll_anim.active = false;
        }
    }

    // Viewport (Y)
    y_threshold := fnt_get_line_height() * 6; // @Todo :WhiteSpacesAfterLastRow
    my := fnt_get_line_height(find_row_index(buffer, editor.cursor.pos));
    my = r.h - my + editor.top_offset;

    target = editor.top_offset;
    if my - y_threshold < 0 {
        target += abs(my - y_threshold);
    } else if my + y_threshold > r.h {
        target -= (my + y_threshold) - (r.h);
        if target < 0 then target = 0;
    }

    if target != editor.top_offset {
        if animation_duration {
            anim_y: Anim;
            anim_y.active = true;
            anim_y.start  = editor.top_offset;
            anim_y.target = target;
            anim_y.duration = animation_duration;
            anim_y.started_at = frame_time64;
            editor.y_scroll_anim = anim_y;
        } else {
            editor.top_offset = target;
            editor.y_scroll_anim.active = false;
        }
    }

    redraw_requested = true;
}

scroll_up :: (editor: *Editor) {
    // @Todo: Handle the touchpad scrolling!

    assert(editor.active_buffer != null);
    buffer := editor.active_buffer;
    r := editor.rect_for_draw;
    if r.w == 0 || r.h == 0 return; // ???

    first_ri := buffer.row_table.count-1;
    first_visible_ri := first_visible_row_index(editor, buffer);
    target_ri := first_visible_row_index(editor, buffer);
    target_ri -= 3;
    if target_ri < 0 then target_ri = 0;

    // Viewport (Y)
    target := ifx target_ri == 0 then 0 else fnt_get_line_height(target_ri) + r_font.default_line_spacing;
    
    editor.top_offset = target;
    editor.y_scroll_anim.active = false;

    redraw_requested = true;
}

scroll_down :: (editor: *Editor) {
    // @Todo: Handle the touchpad scrolling! 
    assert(editor.active_buffer != null);
    buffer := editor.active_buffer;
    r := editor.rect_for_draw;
    if r.w == 0 || r.h == 0 return; // ???

    // Have to subtract the threshold because in this case we want to the top of the 6. row top not the bottom of it.
    y_threshold := fnt_get_line_height() * (6-1); // :WhiteSpacesAfterLastRow

    last_ri := buffer.row_table.count-1;
    last_visible_ri := last_visible_row_index(editor, buffer);
    if last_visible_ri == last_ri {
        if editor.top_offset + editor.rect_for_draw.h - y_threshold > fnt_get_line_height(last_ri) + r_font.default_line_spacing {
            return;
        }
    }
    
    target_ri := first_visible_row_index(editor, buffer);
    target_ri += 3;
    Clamp(*target_ri, 0, last_ri);

    // Viewport (Y)
    target := fnt_get_line_height(target_ri) + r_font.default_line_spacing; // add the line spacing so we get the bottom position of the row
    editor.top_offset = target;
    editor.y_scroll_anim.active = false;

    redraw_requested = true;
}

scroll_left :: (editor: *Editor) {
    buffer := editor.active_buffer;
    assert(editor.active_buffer != null);
    r := editor.rect_for_draw;
    if r.w == 0 || r.h == 0 return; // ???
    
    target := editor.left_offset - r_font.em_width * 6;
    if target < 0 target = 0;
    editor.left_offset = target;
    redraw_requested = true;
}

scroll_right :: (editor: *Editor) {
    buffer := editor.active_buffer;
    assert(editor.active_buffer != null);
    r := editor.rect_for_draw;
    if r.w == 0 || r.h == 0 return; // ???
    
    max_width := 0;
    si := first_visible_row_index(editor, buffer);
    ei := last_visible_row_index(editor, buffer);
    for i: si..ei {
        row := buffer.row_table[i];
        str := get_row_as_string(buffer, row);
        w := measure_text_width(r_font, str);
        if w > max_width then max_width = w;
    }
    
    target := editor.left_offset + r_font.em_width * 6;
    if cast(s64, target + r.w) < cast(s64)max_width {
        editor.left_offset = target;
        redraw_requested = true;
    } else if xx max_width > editor.left_offset + r.w {
        max_possible_x := max_width - r.w;
        editor.left_offset = max_possible_x;
    }
}

find_row :: inline (using buffer: *Buffer, byte_pos: s64) -> Row_Info {
    assert(buffer.initialized, "buffer: %\n", buffer.*);
    index := find_row_index(buffer, byte_pos);
    assert(index < row_table.count, "buffer: %\n", buffer.*);
    return row_table[index];
}

find_row_index :: (using buffer: *Buffer, byte_pos: s64) -> s64 {
    if byte_pos == 0 return 0;
    assert(row_table.count != 0);
    for row, row_index: row_table {
        if byte_pos <= row.end {
            return row_index;
        }
    }
    return row_table.count-1;
}

first_visible_row_index :: (editor: *Editor, using buffer: *Buffer) -> s64 {
    line_height := fnt_get_line_height();
    start_row: s64 = xx (editor.top_offset / line_height);
    start_row = clamp(start_row - 1, 0, row_table.count-1);
    return start_row;
}

last_visible_row_index :: (editor: *Editor, using buffer: *Buffer) -> s64 {
    viewport_h := editor.rect_for_draw.h;// window_height-footer_height*2; // @Hacky
    line_height := fnt_get_line_height();
    end_row: s64 = xx ((editor.top_offset + viewport_h) / line_height);
    end_row = clamp(end_row+1, 0, row_table.count-1);
    return end_row;
}

first_visible_row :: inline (editor: *Editor, buffer: *Buffer) -> Row_Info {
    index := first_visible_row_index(editor, buffer);;
    return buffer.row_table[index];
}

last_visible_row :: inline (editor: *Editor, using buffer: *Buffer) -> Row_Info {
    index := last_visible_row_index(editor, buffer);
    return buffer.row_table[index];
}

get_selected_row_indices :: (buffer: *Buffer, cursor: *Cursor) -> [] s64 /* Temp */ {
    start, end := selected_range(cursor);
    start_row := find_row_index(buffer, start);
    end_row := find_row_index(buffer, end);
    count := max(1, end_row - start_row);
     
    rows: [..] s64;
    rows.allocator = temporary_allocator;
    array_reserve(*rows, max(1, end_row - start_row));
    
    for start_row..end_row {
        array_add(*rows, it);    
    }
    
    return rows;
}

byte_pos_to_row_col_index :: (buffer: *Buffer, byte_pos: s64) -> s64 {
    assert(byte_pos <= buffer.count, "byte_pos: % ; buffer.count: %\n", byte_pos, buffer.count);
    row := find_row(buffer, byte_pos);
    col := 0;
    pos := row.start;
    while pos < byte_pos {
        col += 1;
        pos += 1 + trailingBytesForUTF8[buffer.data[pos]];
    }
    return col;
}

// @Cleanup: Better name!!!
byte_pos_from_mouse_xy :: (editor: *Editor, buffer: *Buffer, mx: s64, my: s64) -> s64 {
    if mx < 0 || my < 0 return -1;

    rect := editor.rect_for_draw;
    my -= xx (window_height - (rect.y + rect.h));
    my = max(0, my);

    approx_row_index := cast(s64)floor((my + editor.top_offset) / fnt_get_line_height());
    if approx_row_index >= buffer.row_table.count return -1;
    
    rs := get_row_as_string(buffer, approx_row_index);
    ch := r_font.character_height;
    left := cast(float32)rect.x;
    bottom := (rect.h + rect.y) - fnt_get_line_height(approx_row_index+1) + editor.top_offset;
    
    ptr := rs.data;
    while rs.count {
        if cast(float, mx + editor.left_offset) <= left break;
        cw := Simp.get_character_width_in_pixels(r_font, rs.data, .LEFT_JUSTIFIED);
        left += cw;
        bytes := 1 + trailingBytesForUTF8[rs[0]];
        rs = advance(rs, bytes);
        ptr += bytes;
    }
    
    idx := ptr - buffer.data;
    Clamp(*idx, 0, buffer.count);
    
    return idx;
    
    /*
    if rs {
        log(">> '%'\n", string.{count=1 + trailingBytesForUTF8[rs[0]], data=rs.data});
        return true;
    } else {
        return false, -1; // @Todo
    }
    */
}

get_row_index_from_y_px :: (y: float, y_is_relative := false) -> (row_index: s64) {
    editor, buffer := get_active_editor_and_buffer();
    if y_is_relative {
        y += editor.top_offset;
    }
    approx_index := cast(s64)floor(y / fnt_get_line_height());
    if (approx_index > buffer.row_table.count - 1) || (approx_index < 0) return -1;
    return approx_index;
}

get_cursor_x :: inline (buffer: *Buffer, cursor: *Cursor, font: *Simp.Dynamic_Font = null) -> s64 {
    if cursor.pos == 0 return 0;
    if cursor.x_cache != -1 return cursor.x_cache;

    // @Speed !!!!!! the prepare_text is so slooow!

    cx := 0;
    defer cursor.x_cache = cx; // @Temporary
    row := find_row(buffer, cursor.pos);
    if row.start == cursor.pos return 0;

    s := get_row_as_string(buffer, row);
    s = slice(s, 0, cursor.pos - row.start);

    if !font then font = r_font;
    cx = measure_text_width(font, s);

    return cx;
}

// @Cleanup: Remove it, because we have the seek_previous_utf8_char or something like that.
prev_char_byte_offset :: (using buffer: *Buffer, start: s64) -> s64 {
    if start == 0 return 0;

    ptr := buffer.data + start;
    ptr -= 1;

    first_bit := ptr.* & 0x80;
    if first_bit == 0x0 return ptr - buffer.data; // 1 byte length char

    // Cursor (caret) movement is based on characters, not bytes - this issue should never occur!
    first_2bit := ptr.* & 0xc0;
    assert(first_2bit != 0xc0, "The start byte (buffer.data+start) is in the middle of a Unicode character.");
    assert(first_2bit == 0x80, "Invalid UTF-8"); // the first bit check happens above

    bytes := 1;
    while (ptr.* & 0xc0) == 0x80 && (ptr > buffer.data) {
        ptr -= 1;
        bytes += 1;
        assert(bytes <= 4, "Invalid UTF-8! We expect less than 5 bytes but we got %", bytes); // it's not totally correct
    }

    assert((ptr.* & 0xc0) == 0xc0, "No more characters are left, and we don't have the byte indicating the Unicode character's byte length.\n");

    return ptr - buffer.data;
}

init_editors :: () {
    e: *Editor;
    
    e = get_left_editor();
    e.ui_id           = .editor_left;
    e.scrollbar_ui_id = .editor_left_scrollbar;
    e.tabs_ui_id      = .editor_left_tabs;
    
    e = get_right_editor();
    e.ui_id           = .editor_right;
    e.scrollbar_ui_id = .editor_right_scrollbar;
    e.tabs_ui_id      = .editor_right_tabs;
    
    e = get_bottom_editor();
    e.ui_id           = .editor_bottom;
    e.scrollbar_ui_id = .editor_bottom_scrollbar;
    e.tabs_ui_id      = .editor_bottom_tabs;
    e.hide_line_numbers  = true;
}

init_editor_buffers :: (files_from_cmdline: [] string) {
    active_editor = *editors[0];
    active_editor.visible = true;
    
    if !files_from_cmdline {
        e := get_left_editor();
        b := create_or_find_empty_buffer(e);
        change_active_buffer(e, b);
    }
    
    if files_from_cmdline.count == 2 {
        // @Temporary
        b := open_file_or_create_empty_buffer(*editors[0], files_from_cmdline[0]);
        change_active_buffer(*editors[0], b);
        b = open_file_or_create_empty_buffer(*editors[1], files_from_cmdline[1]);
        change_active_buffer(*editors[1], b);

        editors[0].visible = true;
        editors[1].visible = true;

    } else {
        for filepath: files_from_cmdline {
            e := *editors[it_index % editors.count];
            b := open_file_or_create_empty_buffer(e, filepath);
            change_active_buffer(e, b);
            
            e.visible = true;
        }
    }

    change_active_editor(get_left_editor());
}

init_editor_commands :: (custom_commands: [] Editor_Command) {
    editor := get_bottom_editor();
    
    for tab: editor.tabs {
        if tab.kind == .normal && custom_commands.count { // @Temporary: We delete the initial empty buffer!
            assert(editor.tabs.count == 1, "tab: %\n", tab.*);
            buffer_destroy(tab);
        }
    }
    editor.active_buffer = null;
    array_reset_keeping_memory(*editor.tabs);

    for * editor_commands {
        if it.buffer {
            buffer_destroy(it.buffer);
            it.buffer = null;
        }
    }
    array_reset_keeping_memory(*editor_commands);
        
    for DEFAULT_EDITOR_COMMANDS {
        cmd := array_add2(*editor_commands);
        cmd.proc = it.proc;
        cmd.custom_command = false;
        modify_string(*cmd.name, it.name);
        // ll("added (default): %\n", cmd.*);
    }
    
    for custom_commands {
        cmd := array_add2(*editor_commands);
        cmd.proc = null;
        cmd.custom_command = true;
        modify_string(*cmd.name, it.name);
        modify_string(*cmd.exec, it.exec);
        modify_string(*cmd.workdir, it.workdir);
        cmd.buffer = create_stdout_buffer();
        modify_string(*cmd.buffer.name, cmd.name);
        maybe_add_buffer_to_editor_tabs(editor, cmd.buffer);
        // ll("added (custom): %\n", cmd.*);
    }
    
    for editor_commands {
        if it.buffer {
            change_active_buffer(editor, it.buffer);
            break;
        }
    }
    
}

maybe_add_buffer_to_editor_tabs :: (editor: *Editor, buffer: *Buffer, append_to_end := false) {
    found := find_buffer_within_editor_tabs(editor, buffer);
    if found return;
    
    found=, index := find_buffer_within_editor_tabs(editor, editor.active_buffer);
    if found && !append_to_end {
        array_insert_at(*editor.tabs, buffer, index + 1); // Add the tab next to the currently active tab (buffer)
    } else {
        // Maybe it's the first buffer of the editor so at this point no buffer is exists in the editor.tabs array,
        // mainly because we call this procedure in the change_active_buffer() before we assign the buffer to the editor.active_buffer.
        // so the editor.active_buffer is must be null! I guess this is the only place where we allow this behaviour.
        
        assert(editor.active_buffer == null);
        array_add(*editor.tabs, buffer);
    }
}

remove_buffer_from_editor_tabs :: (editor: *Editor, buffer: *Buffer) -> (found_and_removed: bool) {
    for tab, index: editor.tabs {
        if tab == buffer {
            if editor.active_buffer == tab {
                if index + 1 < editor.tabs.count {
                    change_active_buffer(editor, editor.tabs[index + 1]);
                } else if index - 1 >= 0 {
                    change_active_buffer(editor, editor.tabs[index - 1]);
                } else {
                    editor.active_buffer = null;
                    editor.visible = false;
                    if active_editor == editor {
                        active_editor = null;
                        for *e: editors {
                            if e == editor || get_bottom_editor() continue;
                            if e.tabs {
                                change_active_editor(e);
                                break;
                            }
                        }
                        if !active_editor {
                            mode = .SPLASH;
                        }
                    }
                }
                 // else {
                    // new_buffer := create_or_find_empty_buffer(editor); // this gives a new buffer or a buffer that was uninitialized
                    // change_active_buffer(editor, new_buffer);
                // }
            }
        
            array_ordered_remove_by_index(*editor.tabs, index);
            
            return true;
        }
    }
    
    return false;
}

find_buffer_within_editor_tabs :: (editor: *Editor, buffer: *Buffer) -> (found: bool, index: s64) {
    for tab, index: editor.tabs {
        if tab == buffer then return true, index;
    }
    
    return false, -1;
}

#if DEBUG {
    dump_buffer_histories :: (using buffer: *Buffer) {
        #if !DEBUG { return; }

        fname := path_filename(buffer.filepath);
        if !fname  {
            assert(false);
            return;
        }

        fpath := tprint("dumps/%", fname);
        File.file_delete(fpath);
        ok := File.write_entire_file(fpath, to_string(buffer));
        if !ok {
            assert(false);
            return;
        }
        
        b: String_Builder;
        init_string_builder(*b);
        
        append_by_pointer(*b, *history_index);
        append_by_pointer(*b, *history.count);
        
        for history {
            append(*b, it.text);
            append(*b, 0);
            append(*b, it.old_text);
            append(*b, 0);
            append_by_pointer(*b, *it.range);
            append_by_pointer(*b, *it.cursor);
            append_by_pointer(*b, *it.type);
            append_by_pointer(*b, *it.modtime);
            append_by_pointer(*b, *it.hash);
        }
        
        s := builder_to_string(*b);
        defer free(s);
        fpath = tprint("dumps/%-history", fname);
        File.file_delete(fpath);
        ok = File.write_entire_file(fpath, s);
        if !ok {
            assert(false);
        }
        
        dialog_confirm("Hisotry dump saved!", options=.OK|.ICONINFORMATION);
    }

    load_dump_buffer_history :: () {
        #if !DEBUG { return; }

        e, b := get_active_editor_and_buffer();
        fname := path_filename(b.filepath);
        if !fname  {
            assert(false);
            return;
        }

        for *e: editors {
            close_tab(e, e.active_buffer);
        }
        
        fpath := tprint("dumps/%", fname);
        b = open_file_or_create_empty_buffer(e, fpath);
        reset_history(b);

        fpath = tprint("dumps/%-history", fname);
        data := File.read_entire_file(fpath);
        defer free_string(*data);
        
        get :: ($T: Type) -> T #expand {
            assert(`data.count >= size_of(T));
            r := cast(*T, `data.data);
            advance(*`data, size_of(T));
            return r.*;
        }
        
        get_string :: () -> string #expand {
            i := find_index_from_left(`data, 0);
            assert(i != -1, "data: %\n", `data);
            defer advance(*`data, i+1);
            r := slice(`data, 0, i);
            return r;
        }
        
        history_index := get(s64);
        expected_history_count := get(s64);
        
        while data.count {
            h: Buffer_History;
            h.text = get_string();
            h.old_text = get_string();
            h.range = get(Range);
            h.cursor = get(Cursor);
            h.type = get(Buffer_History.Type);
            h.modtime = get(float64);
            h.hash = get(u64);
            
            added_history := add_history(e, b, h);
        }
        
        b.history_index = history_index;
        
        // log("Added histories:\n%\n", b.history);
        
        assert(expected_history_count == b.history.count, "expected: % ; got: %\n", expected_history_count, b.history.count);
    }
}

active_editor: *Editor = null;
editors: [3] Editor;
buffers: [..] *Buffer;

editor_panels_auto_size := true;
editor_panels_width     := 0.0;
editor_panels_grabbed_x := 0.0;

editor_commands: [..] Editor_Command;

DEFAULT_EDITOR_COMMANDS :: Editor_Command.[
    .{name="Open Editor Config",                proc=(cmd: *Editor_Command) { OpenEditorConfigFile();         }},
    .{name="Open Project Config",               proc=(cmd: *Editor_Command) { OpenProjectConfigFile();        }},
    .{name="Reload Buffer From Disk",           proc=(cmd: *Editor_Command) { ReloadBufferFromDisk();         }},
    .{name="Transform Selection to Snake Case", proc=(cmd: *Editor_Command) { TransformSelectionToSnakeCase(); }},
    
    .{name="[OS] Wait for os event",            proc=(cmd: *Editor_Command) { wait_os_event_before_redraw = !wait_os_event_before_redraw; }},
    
    .{name="[Video] Standard vsync",            proc=(cmd: *Editor_Command) { video_set_vsync(.STANDARD); }},
    .{name="[Video] No Vsync",                  proc=(cmd: *Editor_Command) { video_set_vsync(.DISABLED); }},
    .{name="[Video] Half vsync",                proc=(cmd: *Editor_Command) { video_set_vsync(.HALF    ); }},
    .{name="[Video] Adaptive vsync",            proc=(cmd: *Editor_Command) { video_set_vsync(.ADAPTIVE); }},
    
    .{name="[DEV] Debug infos",                 proc=(cmd: *Editor_Command) { show_debug_info = !show_debug_info; }},
    .{name="[DEV] Show Profiler",               proc=(cmd: *Editor_Command) { show_profiler = !show_profiler; }},
    .{name="[DEV] Draw font metrics lines",     proc=(cmd: *Editor_Command) { show_font_debug_info = !show_font_debug_info; }},
];

BUFFER_PAGE_SIZE :: 4096;

Editor :: struct {
    active_buffer: *Buffer;
    cursor: Cursor;
    
    visible: bool;
    hide_footer: bool;
    hide_line_numbers: bool;
    
    panel_rect:    Rect;
    rect_for_draw: Rect;
    top_offset  := 0.0;
    left_offset := 0.0;
    
    width_anim:    Anim;
    y_scroll_anim: Anim;
    x_scroll_anim: Anim;
    
    ui_id: Ui_Id;
    tabs_ui_id: Ui_Id;
    scrollbar_ui_id: Ui_Id;
    
    scrollbar_anim: Anim; // @Todo
    scrollbar_opacity := 0.5;
    scrollbar_grabbed_y := 0.0;
    
    tabs: [..] *Buffer;
    tabs_anim: Anim;
    tabs_left_offset := 0.0;
    tabs_force_offset_check := false;
}

Buffer :: struct {
    id: u64;

    data:      *u8; @NeedsFree(c_free)
    count:     s64;
    allocated: s64;
    
    hash:      u64;
    disk_hash: u64;

    should_reload_from_disk: bool; // @Cleanup Remove
    exists_on_disk:          bool; // @Cleanup Remove
    disk_state: enum u8 {not_exists; exists; modified; removed;} = .not_exists;

    initialized: bool;
    dirty: bool;
    was_dirty_on_frame: bool;
    tokenization_requested: bool;
    readonly: bool;

    kind: enum u8 { normal; editor_config; stdout; } = .normal;
    pinned: bool;
    stdout_in_progress: bool; // @Temporary
    stdout_stalled: bool;     // @Temporary

    colors: [] Color; @NeedsFree(c_free)
    row_table: [..] Row_Info; @NeedsFree(array_reset)
    cursor_backup: [editors.count] Cursor;
    
    language: Language = .PLAIN_TEXT; // @Todo: It's mainly for the system buffers like logs or console output etc..
    
    history: [..] Buffer_History; @NeedsFree(array_reset)
    history_index: s64 = -1;
    history_edit_group_id_stack: [..] u64; @NeedsFree(array_reset)
    history_current_edit_group_id: u64 = 0;
    
    name: string; @NeedsFree(free_string)
    filepath: string; @NeedsFree(free_string)
    modtime: float64;
    last_writetime: Apollo_Time;

    quads_for_code_run: [..] Code_Font_Quad; @NeedsFree(array_reset)

    Code_Font_Quad :: struct {
        quad: Simp.Font_Quad;
        color := Vector4.{1, 1, 1, 1.0};
    }

    // For measurements
    tokenization_time: float64 = 0.0;
    row_table_recalc_time: float64 = 0.0;
    
    //code_render_time: MultiSample_Measurement;
}

Buffer_History :: struct {
    text: string;
    old_text: string; // FOR .REPLACE!
    range: Range;
    cursor: Cursor;
    type: Buffer_History.Type = .UNDEFINED;
    modtime: float64;
    edit_group_id: u64;
    
    #if DEBUG {
        hash: u64;
        snapshot: string;
    }

    Type :: enum u8 {
        UNDEFINED :: 0;
        INSERT;
        DELETE;
        REPLACE;
    }
}

// @Speed: Shrink the struct size because we use 3  8 bytes per row which is quite inefficient!
Row_Info :: struct {
    start: s64;
    end:   s64;
    size:  s64;
}

Editor_Command_Proc :: #type (self: *Editor_Command);
Editor_Command :: struct {
    name:   string; // required
    proc: Editor_Command_Proc = null; // Reserved for pre-defined things
    custom_command := false;
    exec := ""; // required
    hotkey := "";
    workdir := "";
    panel_state: enum u8 {none; partial; full;} = .partial;
    buffer: *Buffer;
}

#scope_file

///////////////////////////////////////////
// Code Generation

__BUFFER_DESTROY_CODE :: #run -> string {
    Buffer_Member_Free :: struct {
        member: Type_Info_Struct_Member;
        handled: bool;
        proc_name: string;
        // code: Code;
    }
    
    buffer_members_to_free: [..] Buffer_Member_Free;

    info_struct := type_info(Buffer);
    for member: info_struct.members {
        if member.flags & .CONSTANT  continue;
        
        // @Todo: Check if array element type is struct or the type is a struct that has to be freed recursively.
        // if member.name == "history" {
            // info_array := cast(*Type_Info_Array) member.type;
            // log(">> %\n", info_array.element_type.*);
        // }
        
        for note: member.notes {
            if begins_with(note, "NeedsFree") {
                // @Todo: Check if the proc_name is exists.
                proc_name := advance(note, "NeedsFree".count);
                proc_name = trim(proc_name, "()");
                assert(!!proc_name, "You should specify the procedure for the '%' member of Buffer.\n", member.name);
                
                array_add(*buffer_members_to_free, .{member=member, proc_name=proc_name});
            }
        }
    }
    
    builder: String_Builder;
    
    for * buffer_members_to_free {
        type := it.member.type.type;
        if it.proc_name == {
            case "c_free";
                it.handled = true;
                if type == {
                    case .POINTER;
                        print(*builder, "if buffer.%1 != null then c_free(buffer.%1);\n", it.member.name);
                    case .ARRAY;
                        print(*builder, "if buffer.%1.data != null && buffer.%1.count then c_free(buffer.%1.data);\n", it.member.name);
                    case;
                        assert(false, "Unhandled member: '%'\n", it.member.name);
                };
                
            case "free_string";
                it.handled = true;
                assert(type == .STRING, "Invalid buffer member given for %(). Member: '%'\n", it.proc_name, it.member.name);
                print(*builder, "free_string(*%);\n", it.member.name);
                
            case "array_reset";
                it.handled = true;
                assert(type == .ARRAY, "Invalid buffer member type given for %(). Member: '%'.\n", it.proc_name, it.member.name);
                print(*builder, "array_reset(*%1);\n", it.member.name);
                
            case;
                assert(false, "Unhandled free procedure '%' for this member: '%'!\n", it.proc_name, it.member.name);
        }
    }
    
    for * buffer_members_to_free {
        assert(it.handled, "Unhandled member: '%'! You should define a procedure for freeing it!\n", it.member.name);
    }
    
    code := builder_to_string(*builder);
    // log("\n-------------\nCODE:\n\n%\n----------\n\n", code);
    return code;
}